
// ==========================================================================
//  GPPG error listing for yacc source file <SimpleScriptParser.y - 2017/12/6 23:05:45>
// ==========================================================================
//  Version:  1.5.2
//  Machine:  小兰
//  DateTime: 2017/12/14 21:41:51
//  UserName: stern
// ==========================================================================


%using SimpleScript.RunTime;

%namespace SimpleScript.Analyzing

%{
	SymbolTable symTable = SymbolTable.GetInstance;
	public StatementList program = new StatementList();
%}

%start program

%union {
    public long Integer;
    public string String;
    public double Double;
	public bool Bool;
	public Expression expr;
	public StatementList statementList;
	public IStatement  statement;
}
// Defining Tokens
%token COMMENT
%token <String>	 PROGRAM_NAME
%token <Integer> INTEGER_LITERAL
%token <Double>	 DOUBLE_LITERAL
%token <Bool>	 BOOL_LITERAL
%token <String>	 STRING_LITERAL
%token EOL

%token START
%token END

// move Statement
%token JOINT
%token LINEAR
%token CIRCULAR

//welding
%token ARC
%token WEAVE

//VAR
%token REGISTER
%token POSREGISTER
%token DOUT
%token DIN

// SPEED
%token PERCENT
%token MM_SEC
%token CM_MIN
%token INCH_MIN
%token DEG_SEC

//
%token FINE
%token CNT
%token WJNT
%token OFFSET
%token CONDITION
%token SKIP
%token ACC
%token SEC
%token LABEL
%token JUMP
%token CALL
%token PULSE
%token IF
%token SELECT
%token ELSE

%token OP_RIGHT_PAR
%token OP_LEFT_PAR
%token OP_LEFT_BRA
%token OP_RIGHT_BRA
%left OP_ASSIGN
%left OP_ADD OP_MINUS
%left OP_MUL OP_CHU 
%left OP_MOD OP_DIV
%left OP_AND
%left OP_OR
%left OP_EQU
%left OP_NOT_EQU
%left OP_LT
%left OP_GT
%left OP_GT_EQ
%left OP_LT_EQ


// YACC Rules
%%
// Error: NonTerminal symbol "BOOL" has no productions
// Error: NonTerminal symbol "DOUBLE" has no productions
// Error: NonTerminal symbol "OP_MODUL" has no productions
// Error: NonTerminal symbol "STRING" has no productions
// Error: NonTerminal symbol "INT" has no productions
// Error: NonTerminal symbol "DIM" has no productions
// Error: NonTerminal symbol "BEGIN" has no productions
// Error: NonTerminal symbol "AS" has no productions
// Error: NonTerminal symbol "IDENTIFIER" has no productions
// Error: NonTerminal symbol "OP_NOT" has no productions
// Error: NonTerminal symbol "FI" has no productions
// Error: NonTerminal symbol "THEN" has no productions
// Error: NonTerminal symbol "DO" has no productions
// Error: NonTerminal symbol "WHILE" has no productions
// Error: NonTerminal symbol "NEXT" has no productions
// Error: NonTerminal symbol "INPUT" has no productions
// Error: NonTerminal symbol "PRINT" has no productions
// Error: NonTerminal symbol "TO" has no productions
// Error: NonTerminal symbol "FOR" has no productions
// Warning: Terminating DO fixes the following size-1 NonTerminal set
   // {DO}
// Warning: Terminating DOUBLE fixes the following size-1 NonTerminal set
   // {DOUBLE}
// Warning: Terminating INT fixes the following size-1 NonTerminal set
   // {INT}
// Warning: Terminating STRING fixes the following size-1 NonTerminal set
   // {STRING}
// Warning: Terminating BOOL fixes the following size-1 NonTerminal set
   // {BOOL}
// Warning: Terminating AS fixes the following size-1 NonTerminal set
   // {AS}
// Warning: Terminating BEGIN fixes the following size-3 NonTerminal set
   // {program, $accept, BEGIN}
// Error: There are 29 non-terminating NonTerminal Symbols
   //  {program, $accept, BEGIN, statement, varDecl, assignOp, printOp, inputOp, 
   //     forLoop, ifCond, whileLoop, DIM, IDENTIFIER, AS, INT, DOUBLE, BOOL, 
   //     STRING, OP_MODUL, OP_NOT, PRINT, INPUT, FOR, TO, NEXT, THEN, FI, WHILE, 
   //     DO}
// Warning: Terminating IDENTIFIER fixes the following size-3 NonTerminal set
   // {statement, assignOp, IDENTIFIER}
// Warning: Terminating DIM fixes the following size-1 NonTerminal set
   // {DIM}
// Warning: Terminating OP_MODUL fixes the following size-1 NonTerminal set
   // {OP_MODUL}
// Warning: Terminating THEN fixes the following size-1 NonTerminal set
   // {THEN}
// Warning: Terminating NEXT fixes the following size-1 NonTerminal set
   // {NEXT}
// Warning: Terminating WHILE fixes the following size-1 NonTerminal set
   // {WHILE}
// Warning: Terminating FI fixes the following size-1 NonTerminal set
   // {FI}
// Warning: Terminating TO fixes the following size-1 NonTerminal set
   // {TO}
// Warning: Terminating PRINT fixes the following size-3 NonTerminal set
   // {statement, printOp, PRINT}
// Warning: Terminating OP_NOT fixes the following size-1 NonTerminal set
   // {OP_NOT}
// Warning: Terminating FOR fixes the following size-1 NonTerminal set
   // {FOR}
// Warning: Terminating INPUT fixes the following size-1 NonTerminal set
   // {INPUT}
// -------------------------------------------------------------------------------
program			:	BEGIN EOL statementList EOL OP_LEFT_BRA END OP_RIGHT_BRA	{program = $3.statementList;}
				;

statementList	:	/*Empty*/	{if($$.statementList == null)	{$$.statementList = new StatementList();}}

				|	statement	{	if($$.statementList == null)	{$$.statementList = new StatementList();}
									$$.statementList.InsertFront($1.statement);
									
								}
				|	statementList EOL statement	{ $1.statementList.Add($3.statement); $$.statementList = $1.statementList; }
				;
			
//ÔË¶¯Ö¸Áî º¸½ÓÖ¸Áî I/OÖ¸Áî LABELÖ¸Áî JUMPÖ¸Áî CALLÖ¸Áî IFÖ¸Áî SELECTÖ¸Áî WAITÖ¸Áî OFFSETÖ¸Áî PAUSEÖ¸Áî
statement	:	varDecl		{ $$.statement = $1.statement; }
			|	assignOp	{ $$.statement = $1.statement; }
			|	printOp		{ $$.statement = $1.statement; }
			|	inputOp		{ $$.statement = $1.statement; }
			|	forLoop		{ $$.statement = $1.statement; }
			|	ifCond		{ $$.statement = $1.statement; }
			|	whileLoop	{ $$.statement = $1.statement; }
			;
// Variable Declaration
varDecl		:	DIM IDENTIFIER AS INT		{int yId = symTable.Add($2); symTable.SetType(yId, SimpleScriptTypes.Integer); $$.statement = new VriableDeclStatement(yId);}
			|	DIM IDENTIFIER AS DOUBLE	{int yId = symTable.Add($2); symTable.SetType(yId, SimpleScriptTypes.Double);  $$.statement = new VriableDeclStatement(yId);}
			|	DIM IDENTIFIER AS BOOL		{int yId = symTable.Add($2); symTable.SetType(yId, SimpleScriptTypes.Boolean); $$.statement = new VriableDeclStatement(yId);}
			|	DIM IDENTIFIER AS STRING	{int yId = symTable.Add($2); symTable.SetType(yId, SimpleScriptTypes.String);  $$.statement = new VriableDeclStatement(yId);}
			;

			
assignOp	:	IDENTIFIER OP_ASSIGN Expr		{$$.statement = new AssignmentStatement(symTable.GetID($1), $3.expr);}
			;

//Grammmar for expressions.
//E->E+T | E-T | T 
//T->T*F | T/F | F 
//F->N | (E) | V 

/*
Expr		:	MathExpr	{ $$.expr = $1.expr; }
			//|	IDENTIFIER	{ $$.expr = new Expression(symTable.Get($1));}
			|	Literal		{ $$.expr = $1.expr; }
			;
*/
/*
Expr		:	Expr OP_ADD		Term	{ $$.expr = new Expression(Operation.Add,$1.expr,$3.expr); }
			|	Expr OP_MINUS	Term	{ $$.expr = new Expression(Operation.Sub,$1.expr,$3.expr); }	
			|	Term					{ $$.expr = $1.expr; }
			;

Term		:	Term OP_MUL Factor		{ $$.expr = new Expression(Operation.Mul,$1.expr,$3.expr); }
			|	Term OP_DIV Factor		{ $$.expr = new Expression(Operation.Div,$1.expr,$3.expr); }
			|	Factor					{ $$.expr = $1.expr; }
			;

Factor		:	Literal							{ $$.expr = $1.expr; }
			//|	OP_LEFT_PAR Expr OP_RIGHT_PAR	{ $$.expr = $2.expr; }
			|	IDENTIFIER						{ $$.expr = new Expression(symTable.Get($1));}
			;
*/		
/*NumLiteral	:	INTEGER_LITERAL	{$$.expr = new Expression($1);}
			|	DOUBLE_LITERAL	{$$.expr = new Expression($1);}		
			;
*/
Expr		:	OP_LEFT_PAR Expr OP_RIGHT_PAR		{ $$.expr = $2.expr; }
			|	Literal						{ $$.expr = $1.expr; }
			|	IDENTIFIER					{ $$.expr = new Expression(symTable.Get($1));}
			|	Expr OP_ADD Expr			{ $$.expr = new Expression(Operation.Add,$1.expr,$3.expr); }
			|	Expr OP_MINUS Expr			{ $$.expr = new Expression(Operation.Sub,$1.expr,$3.expr); }
			|	OP_MINUS Expr %prec OP_MUL	{ $$.expr = new Expression(Operation.UnaryMinus,null,$2.expr); }
			|	Expr OP_MUL Expr			{ $$.expr = new Expression(Operation.Mul,$1.expr,$3.expr); }
			|	Expr OP_DIV Expr			{ $$.expr = new Expression(Operation.Div,$1.expr,$3.expr); }
			|	Expr OP_MODUL Expr			{ $$.expr = new Expression(Operation.Modul,$1.expr,$3.expr); }
			|	Expr OP_AND Expr			{ $$.expr = new Expression(Operation.And,$1.expr,$3.expr); }		
			|	Expr OP_OR  Expr			{ $$.expr = new Expression(Operation.Or,$1.expr,$3.expr); }		
			|	Expr OP_NOT Expr			{ $$.expr = new Expression(Operation.Not,$1.expr,$3.expr); }		
			|	Expr OP_EQU Expr			{ $$.expr = new Expression(Operation.Equ,$1.expr,$3.expr); }
			|	Expr OP_NOT_EQU Expr		{ $$.expr = new Expression(Operation.NotEqu,$1.expr,$3.expr); }
			|	Expr OP_LT  Expr			{ $$.expr = new Expression(Operation.Lt,$1.expr,$3.expr); }		
			|	Expr OP_GT  Expr			{ $$.expr = new Expression(Operation.Gt,$1.expr,$3.expr); }		
			|	Expr OP_GT_EQ Expr			{ $$.expr = new Expression(Operation.GtEq,$1.expr,$3.expr); }	
			|	Expr OP_LT_EQ Expr			{ $$.expr = new Expression(Operation.LtEq,$1.expr,$3.expr); }	
			;

Literal		:	STRING_LITERAL	{$$.expr = new Expression($1);}
			|	BOOL_LITERAL	{$$.expr = new Expression($1);}
			|	INTEGER_LITERAL	{$$.expr = new Expression($1);}
			|	DOUBLE_LITERAL	{$$.expr = new Expression($1);}		
			;

printOp		:	PRINT Expr	{$$.statement = new PrintStatement($2.expr);}
			;

inputOp		:	INPUT IDENTIFIER {$$.statement = new InputStatement(symTable.GetID($2));}
			;
			
forLoop		:	FOR IDENTIFIER OP_ASSIGN Expr TO Expr EOL forBody NEXT 
				{$$.statement = new ForStatement(symTable.Get($2) as SymbolTableIntegerElement, $4.expr, $6.expr, $8.statementList);}
			;

forBody		:	/*Empty*/			{$$.statementList = new StatementList();}
			|	statementList EOL	{$$.statementList = $1.statementList;}
			;

ifCond		:	IF OP_LEFT_PAR Expr OP_RIGHT_PAR THEN EOL ifBody else FI
				{$$.statement = new IfCondStatement($3.expr,$7.statementList,$8.statementList);}
			;

ifBody		:	/*Empty*/				{$$.statementList = new StatementList();}
			|	statementList EOL		{$$.statementList = $1.statementList;}
			;

else		:	/* Empty */			{$$.statementList = new StatementList();}
			|	ELSE EOL elseBody	{$$.statementList = $3.statementList;}
			;

elseBody	:	/*Empty*/			{$$.statementList = new StatementList();}
			|	statementList EOL	{$$.statementList = $1.statementList;}
			;

whileLoop	:	WHILE OP_LEFT_PAR Expr OP_RIGHT_PAR DO EOL whileBody NEXT
				{$$.statement = new WhileLoopStatement($3.expr,$7.statementList);}
			;

whileBody	:	/*Empty*/			{$$.statementList = new StatementList();}
			|	statementList EOL	{$$.statementList = $1.statementList;}
			;								
%%

// No argument CTOR. By deafult Parser's ctor requires scanner as param.
public Parser(Scanner scn) : base(scn) { }// ==========================================================================

